"use strict";(globalThis.webpackChunkdocs_workspace=globalThis.webpackChunkdocs_workspace||[]).push([[8466],{2151(n,i,e){e.r(i),e.d(i,{assets:()=>t,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"refactor/strict-config","title":"Strict config validation (doctor-only migrations)","description":"Goals","source":"@site/content/moltbot/docs/refactor/strict-config.md","sourceDirName":"refactor","slug":"/refactor/strict-config","permalink":"/moltbot-doc/docs/refactor/strict-config","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"summary":"Strict config validation + doctor-only migrations","read_when":["Designing or implementing config validation behavior","Working on config migrations or doctor workflows","Handling plugin config schemas or plugin load gating"]}}');var l=e(74848),s=e(28453);const r={summary:"Strict config validation + doctor-only migrations",read_when:["Designing or implementing config validation behavior","Working on config migrations or doctor workflows","Handling plugin config schemas or plugin load gating"]},c="Strict config validation (doctor-only migrations)",t={},d=[{value:"Goals",id:"goals",level:2},{value:"Non-goals",id:"non-goals",level:2},{value:"Strict validation rules",id:"strict-validation-rules",level:2},{value:"Plugin schema enforcement",id:"plugin-schema-enforcement",level:2},{value:"Doctor flow",id:"doctor-flow",level:2},{value:"Command gating (when config is invalid)",id:"command-gating-when-config-is-invalid",level:2},{value:"Error UX format",id:"error-ux-format",level:2},{value:"Implementation touchpoints",id:"implementation-touchpoints",level:2},{value:"Tests",id:"tests",level:2}];function a(n){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"strict-config-validation-doctor-only-migrations",children:"Strict config validation (doctor-only migrations)"})}),"\n",(0,l.jsx)(i.h2,{id:"goals",children:"Goals"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Reject unknown config keys everywhere"})," (root + nested)."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Reject plugin config without a schema"}),"; don\u2019t load that plugin."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Remove legacy auto-migration on load"}),"; migrations run via doctor only."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Auto-run doctor (dry-run) on startup"}),"; if invalid, block non-diagnostic commands."]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"non-goals",children:"Non-goals"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Backward compatibility on load (legacy keys do not auto-migrate)."}),"\n",(0,l.jsx)(i.li,{children:"Silent drops of unrecognized keys."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"strict-validation-rules",children:"Strict validation rules"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Config must match the schema exactly at every level."}),"\n",(0,l.jsx)(i.li,{children:"Unknown keys are validation errors (no passthrough at root or nested)."}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"plugins.entries.<id>.config"})," must be validated by the plugin\u2019s schema.\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["If a plugin lacks a schema, ",(0,l.jsx)(i.strong,{children:"reject plugin load"})," and surface a clear error."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["Unknown ",(0,l.jsx)(i.code,{children:"channels.<id>"})," keys are errors unless a plugin manifest declares the channel id."]}),"\n",(0,l.jsxs)(i.li,{children:["Plugin manifests (",(0,l.jsx)(i.code,{children:"moltbot.plugin.json"}),") are required for all plugins."]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"plugin-schema-enforcement",children:"Plugin schema enforcement"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Each plugin provides a strict JSON Schema for its config (inline in the manifest)."}),"\n",(0,l.jsxs)(i.li,{children:["Plugin load flow:\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:["Resolve plugin manifest + schema (",(0,l.jsx)(i.code,{children:"moltbot.plugin.json"}),")."]}),"\n",(0,l.jsx)(i.li,{children:"Validate config against the schema."}),"\n",(0,l.jsx)(i.li,{children:"If missing schema or invalid config: block plugin load, record error."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["Error message includes:\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Plugin id"}),"\n",(0,l.jsx)(i.li,{children:"Reason (missing schema / invalid config)"}),"\n",(0,l.jsx)(i.li,{children:"Path(s) that failed validation"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.li,{children:"Disabled plugins keep their config, but Doctor + logs surface a warning."}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"doctor-flow",children:"Doctor flow"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["Doctor runs ",(0,l.jsx)(i.strong,{children:"every time"})," config is loaded (dry-run by default)."]}),"\n",(0,l.jsxs)(i.li,{children:["If config invalid:\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Print a summary + actionable errors."}),"\n",(0,l.jsxs)(i.li,{children:["Instruct: ",(0,l.jsx)(i.code,{children:"moltbot doctor --fix"}),"."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"moltbot doctor --fix"}),":\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Applies migrations."}),"\n",(0,l.jsx)(i.li,{children:"Removes unknown keys."}),"\n",(0,l.jsx)(i.li,{children:"Writes updated config."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"command-gating-when-config-is-invalid",children:"Command gating (when config is invalid)"}),"\n",(0,l.jsx)(i.p,{children:"Allowed (diagnostic-only):"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"moltbot doctor"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"moltbot logs"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"moltbot health"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"moltbot help"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"moltbot status"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"moltbot gateway status"})}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Everything else must hard-fail with: \u201cConfig invalid. Run ",(0,l.jsx)(i.code,{children:"moltbot doctor --fix"}),".\u201d"]}),"\n",(0,l.jsx)(i.h2,{id:"error-ux-format",children:"Error UX format"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Single summary header."}),"\n",(0,l.jsxs)(i.li,{children:["Grouped sections:\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Unknown keys (full paths)"}),"\n",(0,l.jsx)(i.li,{children:"Legacy keys / migrations needed"}),"\n",(0,l.jsx)(i.li,{children:"Plugin load failures (plugin id + reason + path)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"implementation-touchpoints",children:"Implementation touchpoints"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"src/config/zod-schema.ts"}),": remove root passthrough; strict objects everywhere."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"src/config/zod-schema.providers.ts"}),": ensure strict channel schemas."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"src/config/validation.ts"}),": fail on unknown keys; do not apply legacy migrations."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"src/config/io.ts"}),": remove legacy auto-migrations; always run doctor dry-run."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"src/config/legacy*.ts"}),": move usage to doctor only."]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"src/plugins/*"}),": add schema registry + gating."]}),"\n",(0,l.jsxs)(i.li,{children:["CLI command gating in ",(0,l.jsx)(i.code,{children:"src/cli"}),"."]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"tests",children:"Tests"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Unknown key rejection (root + nested)."}),"\n",(0,l.jsx)(i.li,{children:"Plugin missing schema \u2192 plugin load blocked with clear error."}),"\n",(0,l.jsx)(i.li,{children:"Invalid config \u2192 gateway startup blocked except diagnostic commands."}),"\n",(0,l.jsxs)(i.li,{children:["Doctor dry-run auto; ",(0,l.jsx)(i.code,{children:"doctor --fix"})," writes corrected config."]}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,s.R)(),...n.components};return i?(0,l.jsx)(i,{...n,children:(0,l.jsx)(a,{...n})}):a(n)}},28453(n,i,e){e.d(i,{R:()=>r,x:()=>c});var o=e(96540);const l={},s=o.createContext(l);function r(n){const i=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function c(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:r(n.components),o.createElement(s.Provider,{value:i},n.children)}}}]);