"use strict";(globalThis.webpackChunkdocs_workspace=globalThis.webpackChunkdocs_workspace||[]).push([[6342],{59867(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"concepts/session","title":"Session Management","description":"Moltbot treats one direct-chat session per agent as primary. Direct chats collapse to agent:: (default main), while group/channel chats get their own keys. session.mainKey is honored.","source":"@site/content/moltbot/docs/concepts/session.md","sourceDirName":"concepts","slug":"/concepts/session","permalink":"/moltbot-doc/docs/concepts/session","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"summary":"Session management rules, keys, and persistence for chats","read_when":["Modifying session handling or storage"]},"sidebar":"tutorialSidebar","previous":{"title":"\u4ee3\u7406\u5de5\u4f5c\u7a7a\u95f4","permalink":"/moltbot-doc/docs/concepts/agent-workspace"},"next":{"title":"\u4f1a\u8bdd\u6e05\u7406","permalink":"/moltbot-doc/docs/concepts/session-pruning"}}');var o=s(74848),r=s(28453);const t={summary:"Session management rules, keys, and persistence for chats",read_when:["Modifying session handling or storage"]},c="Session Management",d={},l=[{value:"Gateway is the source of truth",id:"gateway-is-the-source-of-truth",level:2},{value:"Where state lives",id:"where-state-lives",level:2},{value:"Session pruning",id:"session-pruning",level:2},{value:"Pre-compaction memory flush",id:"pre-compaction-memory-flush",level:2},{value:"Mapping transports \u2192 session keys",id:"mapping-transports--session-keys",level:2},{value:"Lifecycle",id:"lifecycle",level:2},{value:"Send policy (optional)",id:"send-policy-optional",level:2},{value:"Configuration (optional rename example)",id:"configuration-optional-rename-example",level:2},{value:"Inspecting",id:"inspecting",level:2},{value:"Tips",id:"tips",level:2},{value:"Session origin metadata",id:"session-origin-metadata",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"session-management",children:"Session Management"})}),"\n",(0,o.jsxs)(n.p,{children:["Moltbot treats ",(0,o.jsx)(n.strong,{children:"one direct-chat session per agent"})," as primary. Direct chats collapse to ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<mainKey>"})," (default ",(0,o.jsx)(n.code,{children:"main"}),"), while group/channel chats get their own keys. ",(0,o.jsx)(n.code,{children:"session.mainKey"})," is honored."]}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"session.dmScope"})," to control how ",(0,o.jsx)(n.strong,{children:"direct messages"})," are grouped:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"main"})," (default): all DMs share the main session for continuity."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"per-peer"}),": isolate by sender id across channels."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"per-channel-peer"}),": isolate by channel + sender (recommended for multi-user inboxes)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"per-account-channel-peer"}),": isolate by account + channel + sender (recommended for multi-account inboxes).\nUse ",(0,o.jsx)(n.code,{children:"session.identityLinks"})," to map provider-prefixed peer ids to a canonical identity so the same person shares a DM session across channels when using ",(0,o.jsx)(n.code,{children:"per-peer"}),", ",(0,o.jsx)(n.code,{children:"per-channel-peer"}),", or ",(0,o.jsx)(n.code,{children:"per-account-channel-peer"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"gateway-is-the-source-of-truth",children:"Gateway is the source of truth"}),"\n",(0,o.jsxs)(n.p,{children:["All session state is ",(0,o.jsx)(n.strong,{children:"owned by the gateway"})," (the \u201cmaster\u201d Moltbot). UI clients (macOS app, WebChat, etc.) must query the gateway for session lists and token counts instead of reading local files."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["In ",(0,o.jsx)(n.strong,{children:"remote mode"}),", the session store you care about lives on the remote gateway host, not your Mac."]}),"\n",(0,o.jsxs)(n.li,{children:["Token counts shown in UIs come from the gateway\u2019s store fields (",(0,o.jsx)(n.code,{children:"inputTokens"}),", ",(0,o.jsx)(n.code,{children:"outputTokens"}),", ",(0,o.jsx)(n.code,{children:"totalTokens"}),", ",(0,o.jsx)(n.code,{children:"contextTokens"}),"). Clients do not parse JSONL transcripts to \u201cfix up\u201d totals."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"where-state-lives",children:"Where state lives"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["On the ",(0,o.jsx)(n.strong,{children:"gateway host"}),":\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Store file: ",(0,o.jsx)(n.code,{children:"~/.clawdbot/agents/<agentId>/sessions/sessions.json"})," (per agent)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Transcripts: ",(0,o.jsx)(n.code,{children:"~/.clawdbot/agents/<agentId>/sessions/<SessionId>.jsonl"})," (Telegram topic sessions use ",(0,o.jsx)(n.code,{children:".../<SessionId>-topic-<threadId>.jsonl"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["The store is a map ",(0,o.jsx)(n.code,{children:"sessionKey -> { sessionId, updatedAt, ... }"}),". Deleting entries is safe; they are recreated on demand."]}),"\n",(0,o.jsxs)(n.li,{children:["Group entries may include ",(0,o.jsx)(n.code,{children:"displayName"}),", ",(0,o.jsx)(n.code,{children:"channel"}),", ",(0,o.jsx)(n.code,{children:"subject"}),", ",(0,o.jsx)(n.code,{children:"room"}),", and ",(0,o.jsx)(n.code,{children:"space"})," to label sessions in UIs."]}),"\n",(0,o.jsxs)(n.li,{children:["Session entries include ",(0,o.jsx)(n.code,{children:"origin"})," metadata (label + routing hints) so UIs can explain where a session came from."]}),"\n",(0,o.jsxs)(n.li,{children:["Moltbot does ",(0,o.jsx)(n.strong,{children:"not"})," read legacy Pi/Tau session folders."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"session-pruning",children:"Session pruning"}),"\n",(0,o.jsxs)(n.p,{children:["Moltbot trims ",(0,o.jsx)(n.strong,{children:"old tool results"})," from the in-memory context right before LLM calls by default.\nThis does ",(0,o.jsx)(n.strong,{children:"not"})," rewrite JSONL history. See ",(0,o.jsx)(n.a,{href:"/concepts/session-pruning",children:"/concepts/session-pruning"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"pre-compaction-memory-flush",children:"Pre-compaction memory flush"}),"\n",(0,o.jsxs)(n.p,{children:["When a session nears auto-compaction, Moltbot can run a ",(0,o.jsx)(n.strong,{children:"silent memory flush"}),"\nturn that reminds the model to write durable notes to disk. This only runs when\nthe workspace is writable. See ",(0,o.jsx)(n.a,{href:"/concepts/memory",children:"Memory"})," and\n",(0,o.jsx)(n.a,{href:"/concepts/compaction",children:"Compaction"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"mapping-transports--session-keys",children:"Mapping transports \u2192 session keys"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Direct chats follow ",(0,o.jsx)(n.code,{children:"session.dmScope"})," (default ",(0,o.jsx)(n.code,{children:"main"}),").\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"main"}),": ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<mainKey>"})," (continuity across devices/channels).\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Multiple phone numbers and channels can map to the same agent main key; they act as transports into one conversation."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"per-peer"}),": ",(0,o.jsx)(n.code,{children:"agent:<agentId>:dm:<peerId>"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"per-channel-peer"}),": ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<channel>:dm:<peerId>"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"per-account-channel-peer"}),": ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<channel>:<accountId>:dm:<peerId>"})," (accountId defaults to ",(0,o.jsx)(n.code,{children:"default"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["If ",(0,o.jsx)(n.code,{children:"session.identityLinks"})," matches a provider-prefixed peer id (for example ",(0,o.jsx)(n.code,{children:"telegram:123"}),"), the canonical key replaces ",(0,o.jsx)(n.code,{children:"<peerId>"})," so the same person shares a session across channels."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Group chats isolate state: ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<channel>:group:<id>"})," (rooms/channels use ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<channel>:channel:<id>"}),").\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Telegram forum topics append ",(0,o.jsx)(n.code,{children:":topic:<threadId>"})," to the group id for isolation."]}),"\n",(0,o.jsxs)(n.li,{children:["Legacy ",(0,o.jsx)(n.code,{children:"group:<id>"})," keys are still recognized for migration."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["Inbound contexts may still use ",(0,o.jsx)(n.code,{children:"group:<id>"}),"; the channel is inferred from ",(0,o.jsx)(n.code,{children:"Provider"})," and normalized to the canonical ",(0,o.jsx)(n.code,{children:"agent:<agentId>:<channel>:group:<id>"})," form."]}),"\n",(0,o.jsxs)(n.li,{children:["Other sources:\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Cron jobs: ",(0,o.jsx)(n.code,{children:"cron:<job.id>"})]}),"\n",(0,o.jsxs)(n.li,{children:["Webhooks: ",(0,o.jsx)(n.code,{children:"hook:<uuid>"})," (unless explicitly set by the hook)"]}),"\n",(0,o.jsxs)(n.li,{children:["Node runs: ",(0,o.jsx)(n.code,{children:"node-<nodeId>"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Reset policy: sessions are reused until they expire, and expiry is evaluated on the next inbound message."}),"\n",(0,o.jsxs)(n.li,{children:["Daily reset: defaults to ",(0,o.jsx)(n.strong,{children:"4:00 AM local time on the gateway host"}),". A session is stale once its last update is earlier than the most recent daily reset time."]}),"\n",(0,o.jsxs)(n.li,{children:["Idle reset (optional): ",(0,o.jsx)(n.code,{children:"idleMinutes"})," adds a sliding idle window. When both daily and idle resets are configured, ",(0,o.jsx)(n.strong,{children:"whichever expires first"})," forces a new session."]}),"\n",(0,o.jsxs)(n.li,{children:["Legacy idle-only: if you set ",(0,o.jsx)(n.code,{children:"session.idleMinutes"})," without any ",(0,o.jsx)(n.code,{children:"session.reset"}),"/",(0,o.jsx)(n.code,{children:"resetByType"})," config, Moltbot stays in idle-only mode for backward compatibility."]}),"\n",(0,o.jsxs)(n.li,{children:["Per-type overrides (optional): ",(0,o.jsx)(n.code,{children:"resetByType"})," lets you override the policy for ",(0,o.jsx)(n.code,{children:"dm"}),", ",(0,o.jsx)(n.code,{children:"group"}),", and ",(0,o.jsx)(n.code,{children:"thread"})," sessions (thread = Slack/Discord threads, Telegram topics, Matrix threads when provided by the connector)."]}),"\n",(0,o.jsxs)(n.li,{children:["Per-channel overrides (optional): ",(0,o.jsx)(n.code,{children:"resetByChannel"})," overrides the reset policy for a channel (applies to all session types for that channel and takes precedence over ",(0,o.jsx)(n.code,{children:"reset"}),"/",(0,o.jsx)(n.code,{children:"resetByType"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["Reset triggers: exact ",(0,o.jsx)(n.code,{children:"/new"})," or ",(0,o.jsx)(n.code,{children:"/reset"})," (plus any extras in ",(0,o.jsx)(n.code,{children:"resetTriggers"}),") start a fresh session id and pass the remainder of the message through. ",(0,o.jsx)(n.code,{children:"/new <model>"})," accepts a model alias, ",(0,o.jsx)(n.code,{children:"provider/model"}),", or provider name (fuzzy match) to set the new session model. If ",(0,o.jsx)(n.code,{children:"/new"})," or ",(0,o.jsx)(n.code,{children:"/reset"})," is sent alone, Moltbot runs a short \u201chello\u201d greeting turn to confirm the reset."]}),"\n",(0,o.jsx)(n.li,{children:"Manual reset: delete specific keys from the store or remove the JSONL transcript; the next message recreates them."}),"\n",(0,o.jsxs)(n.li,{children:["Isolated cron jobs always mint a fresh ",(0,o.jsx)(n.code,{children:"sessionId"})," per run (no idle reuse)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"send-policy-optional",children:"Send policy (optional)"}),"\n",(0,o.jsx)(n.p,{children:"Block delivery for specific session types without listing individual ids."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json5",children:'{\n  session: {\n    sendPolicy: {\n      rules: [\n        { action: "deny", match: { channel: "discord", chatType: "group" } },\n        { action: "deny", match: { keyPrefix: "cron:" } }\n      ],\n      default: "allow"\n    }\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Runtime override (owner only):"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/send on"})," \u2192 allow for this session"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/send off"})," \u2192 deny for this session"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/send inherit"})," \u2192 clear override and use config rules\nSend these as standalone messages so they register."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"configuration-optional-rename-example",children:"Configuration (optional rename example)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json5",children:'// ~/.clawdbot/moltbot.json\n{\n  session: {\n    scope: "per-sender",      // keep group keys separate\n    dmScope: "main",          // DM continuity (set per-channel-peer/per-account-channel-peer for shared inboxes)\n    identityLinks: {\n      alice: ["telegram:123456789", "discord:987654321012345678"]\n    },\n    reset: {\n      // Defaults: mode=daily, atHour=4 (gateway host local time).\n      // If you also set idleMinutes, whichever expires first wins.\n      mode: "daily",\n      atHour: 4,\n      idleMinutes: 120\n    },\n    resetByType: {\n      thread: { mode: "daily", atHour: 4 },\n      dm: { mode: "idle", idleMinutes: 240 },\n      group: { mode: "idle", idleMinutes: 120 }\n    },\n    resetByChannel: {\n      discord: { mode: "idle", idleMinutes: 10080 }\n    },\n    resetTriggers: ["/new", "/reset"],\n    store: "~/.clawdbot/agents/{agentId}/sessions/sessions.json",\n    mainKey: "main",\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"inspecting",children:"Inspecting"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"moltbot status"})," \u2014 shows store path and recent sessions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"moltbot sessions --json"})," \u2014 dumps every entry (filter with ",(0,o.jsx)(n.code,{children:"--active <minutes>"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"moltbot gateway call sessions.list --params '{}'"})," \u2014 fetch sessions from the running gateway (use ",(0,o.jsx)(n.code,{children:"--url"}),"/",(0,o.jsx)(n.code,{children:"--token"})," for remote gateway access)."]}),"\n",(0,o.jsxs)(n.li,{children:["Send ",(0,o.jsx)(n.code,{children:"/status"})," as a standalone message in chat to see whether the agent is reachable, how much of the session context is used, current thinking/verbose toggles, and when your WhatsApp web creds were last refreshed (helps spot relink needs)."]}),"\n",(0,o.jsxs)(n.li,{children:["Send ",(0,o.jsx)(n.code,{children:"/context list"})," or ",(0,o.jsx)(n.code,{children:"/context detail"})," to see what\u2019s in the system prompt and injected workspace files (and the biggest context contributors)."]}),"\n",(0,o.jsxs)(n.li,{children:["Send ",(0,o.jsx)(n.code,{children:"/stop"})," as a standalone message to abort the current run, clear queued followups for that session, and stop any sub-agent runs spawned from it (the reply includes the stopped count)."]}),"\n",(0,o.jsxs)(n.li,{children:["Send ",(0,o.jsx)(n.code,{children:"/compact"})," (optional instructions) as a standalone message to summarize older context and free up window space. See ",(0,o.jsx)(n.a,{href:"/concepts/compaction",children:"/concepts/compaction"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"JSONL transcripts can be opened directly to review full turns."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Keep the primary key dedicated to 1:1 traffic; let groups keep their own keys."}),"\n",(0,o.jsx)(n.li,{children:"When automating cleanup, delete individual keys instead of the whole store to preserve context elsewhere."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"session-origin-metadata",children:"Session origin metadata"}),"\n",(0,o.jsxs)(n.p,{children:["Each session entry records where it came from (best-effort) in ",(0,o.jsx)(n.code,{children:"origin"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"label"}),": human label (resolved from conversation label + group subject/channel)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"provider"}),": normalized channel id (including extensions)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"from"}),"/",(0,o.jsx)(n.code,{children:"to"}),": raw routing ids from the inbound envelope"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"accountId"}),": provider account id (when multi-account)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"threadId"}),": thread/topic id when the channel supports it\nThe origin fields are populated for direct messages, channels, and groups. If a\nconnector only updates delivery routing (for example, to keep a DM main session\nfresh), it should still provide inbound context so the session keeps its\nexplainer metadata. Extensions can do this by sending ",(0,o.jsx)(n.code,{children:"ConversationLabel"}),",\n",(0,o.jsx)(n.code,{children:"GroupSubject"}),", ",(0,o.jsx)(n.code,{children:"GroupChannel"}),", ",(0,o.jsx)(n.code,{children:"GroupSpace"}),", and ",(0,o.jsx)(n.code,{children:"SenderName"})," in the inbound\ncontext and calling ",(0,o.jsx)(n.code,{children:"recordSessionMetaFromInbound"})," (or passing the same context\nto ",(0,o.jsx)(n.code,{children:"updateLastRoute"}),")."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},28453(e,n,s){s.d(n,{R:()=>t,x:()=>c});var i=s(96540);const o={},r=i.createContext(o);function t(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);