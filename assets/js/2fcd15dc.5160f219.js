"use strict";(globalThis.webpackChunkdocs_workspace=globalThis.webpackChunkdocs_workspace||[]).push([[943],{6992(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"concepts/session-tool","title":"Session Tools","description":"Goal: small, hard-to-misuse tool set so agents can list sessions, fetch history, and send to another session.","source":"@site/content/moltbot/docs/concepts/session-tool.md","sourceDirName":"concepts","slug":"/concepts/session-tool","permalink":"/moltbot-doc/docs/concepts/session-tool","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"summary":"Agent session tools for listing sessions, fetching history, and sending cross-session messages","read_when":["Adding or modifying session tools"]},"sidebar":"tutorialSidebar","previous":{"title":"\u4f1a\u8bdd\u6e05\u7406","permalink":"/moltbot-doc/docs/concepts/session-pruning"},"next":{"title":"\u6a21\u578b\u63d0\u4f9b\u5546","permalink":"/moltbot-doc/docs/concepts/model-providers"}}');var l=n(74848),o=n(28453);const d={summary:"Agent session tools for listing sessions, fetching history, and sending cross-session messages",read_when:["Adding or modifying session tools"]},r="Session Tools",c={},t=[{value:"Tool Names",id:"tool-names",level:2},{value:"Key Model",id:"key-model",level:2},{value:"sessions_list",id:"sessions_list",level:2},{value:"sessions_history",id:"sessions_history",level:2},{value:"sessions_send",id:"sessions_send",level:2},{value:"Channel Field",id:"channel-field",level:2},{value:"Security / Send Policy",id:"security--send-policy",level:2},{value:"sessions_spawn",id:"sessions_spawn",level:2},{value:"Sandbox Session Visibility",id:"sandbox-session-visibility",level:2}];function a(e){const s={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.header,{children:(0,l.jsx)(s.h1,{id:"session-tools",children:"Session Tools"})}),"\n",(0,l.jsx)(s.p,{children:"Goal: small, hard-to-misuse tool set so agents can list sessions, fetch history, and send to another session."}),"\n",(0,l.jsx)(s.h2,{id:"tool-names",children:"Tool Names"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"sessions_list"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"sessions_history"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"sessions_send"})}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"sessions_spawn"})}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"key-model",children:"Key Model"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Main direct chat bucket is always the literal key ",(0,l.jsx)(s.code,{children:'"main"'})," (resolved to the current agent\u2019s main key)."]}),"\n",(0,l.jsxs)(s.li,{children:["Group chats use ",(0,l.jsx)(s.code,{children:"agent:<agentId>:<channel>:group:<id>"})," or ",(0,l.jsx)(s.code,{children:"agent:<agentId>:<channel>:channel:<id>"})," (pass the full key)."]}),"\n",(0,l.jsxs)(s.li,{children:["Cron jobs use ",(0,l.jsx)(s.code,{children:"cron:<job.id>"}),"."]}),"\n",(0,l.jsxs)(s.li,{children:["Hooks use ",(0,l.jsx)(s.code,{children:"hook:<uuid>"})," unless explicitly set."]}),"\n",(0,l.jsxs)(s.li,{children:["Node sessions use ",(0,l.jsx)(s.code,{children:"node-<nodeId>"})," unless explicitly set."]}),"\n"]}),"\n",(0,l.jsxs)(s.p,{children:[(0,l.jsx)(s.code,{children:"global"})," and ",(0,l.jsx)(s.code,{children:"unknown"})," are reserved values and are never listed. If ",(0,l.jsx)(s.code,{children:'session.scope = "global"'}),", we alias it to ",(0,l.jsx)(s.code,{children:"main"})," for all tools so callers never see ",(0,l.jsx)(s.code,{children:"global"}),"."]}),"\n",(0,l.jsx)(s.h2,{id:"sessions_list",children:"sessions_list"}),"\n",(0,l.jsx)(s.p,{children:"List sessions as an array of rows."}),"\n",(0,l.jsx)(s.p,{children:"Parameters:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"kinds?: string[]"})," filter: any of ",(0,l.jsx)(s.code,{children:'"main" | "group" | "cron" | "hook" | "node" | "other"'})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"limit?: number"})," max rows (default: server default, clamp e.g. 200)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"activeMinutes?: number"})," only sessions updated within N minutes"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"messageLimit?: number"})," 0 = no messages (default 0); >0 = include last N messages"]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Behavior:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"messageLimit > 0"})," fetches ",(0,l.jsx)(s.code,{children:"chat.history"})," per session and includes the last N messages."]}),"\n",(0,l.jsxs)(s.li,{children:["Tool results are filtered out in list output; use ",(0,l.jsx)(s.code,{children:"sessions_history"})," for tool messages."]}),"\n",(0,l.jsxs)(s.li,{children:["When running in a ",(0,l.jsx)(s.strong,{children:"sandboxed"})," agent session, session tools default to ",(0,l.jsx)(s.strong,{children:"spawned-only visibility"})," (see below)."]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Row shape (JSON):"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"key"}),": session key (string)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"kind"}),": ",(0,l.jsx)(s.code,{children:"main | group | cron | hook | node | other"})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"channel"}),": ",(0,l.jsx)(s.code,{children:"whatsapp | telegram | discord | signal | imessage | webchat | internal | unknown"})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"displayName"})," (group display label if available)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"updatedAt"})," (ms)"]}),"\n",(0,l.jsx)(s.li,{children:(0,l.jsx)(s.code,{children:"sessionId"})}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"model"}),", ",(0,l.jsx)(s.code,{children:"contextTokens"}),", ",(0,l.jsx)(s.code,{children:"totalTokens"})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"thinkingLevel"}),", ",(0,l.jsx)(s.code,{children:"verboseLevel"}),", ",(0,l.jsx)(s.code,{children:"systemSent"}),", ",(0,l.jsx)(s.code,{children:"abortedLastRun"})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"sendPolicy"})," (session override if set)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"lastChannel"}),", ",(0,l.jsx)(s.code,{children:"lastTo"})]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"deliveryContext"})," (normalized ",(0,l.jsx)(s.code,{children:"{ channel, to, accountId }"})," when available)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"transcriptPath"})," (best-effort path derived from store dir + sessionId)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"messages?"})," (only when ",(0,l.jsx)(s.code,{children:"messageLimit > 0"}),")"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"sessions_history",children:"sessions_history"}),"\n",(0,l.jsx)(s.p,{children:"Fetch transcript for one session."}),"\n",(0,l.jsx)(s.p,{children:"Parameters:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"sessionKey"})," (required; accepts session key or ",(0,l.jsx)(s.code,{children:"sessionId"})," from ",(0,l.jsx)(s.code,{children:"sessions_list"}),")"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"limit?: number"})," max messages (server clamps)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"includeTools?: boolean"})," (default false)"]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Behavior:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"includeTools=false"})," filters ",(0,l.jsx)(s.code,{children:'role: "toolResult"'})," messages."]}),"\n",(0,l.jsx)(s.li,{children:"Returns messages array in the raw transcript format."}),"\n",(0,l.jsxs)(s.li,{children:["When given a ",(0,l.jsx)(s.code,{children:"sessionId"}),", Moltbot resolves it to the corresponding session key (missing ids error)."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"sessions_send",children:"sessions_send"}),"\n",(0,l.jsx)(s.p,{children:"Send a message into another session."}),"\n",(0,l.jsx)(s.p,{children:"Parameters:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"sessionKey"})," (required; accepts session key or ",(0,l.jsx)(s.code,{children:"sessionId"})," from ",(0,l.jsx)(s.code,{children:"sessions_list"}),")"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"message"})," (required)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"timeoutSeconds?: number"})," (default >0; 0 = fire-and-forget)"]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Behavior:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"timeoutSeconds = 0"}),": enqueue and return ",(0,l.jsx)(s.code,{children:'{ runId, status: "accepted" }'}),"."]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"timeoutSeconds > 0"}),": wait up to N seconds for completion, then return ",(0,l.jsx)(s.code,{children:'{ runId, status: "ok", reply }'}),"."]}),"\n",(0,l.jsxs)(s.li,{children:["If wait times out: ",(0,l.jsx)(s.code,{children:'{ runId, status: "timeout", error }'}),". Run continues; call ",(0,l.jsx)(s.code,{children:"sessions_history"})," later."]}),"\n",(0,l.jsxs)(s.li,{children:["If the run fails: ",(0,l.jsx)(s.code,{children:'{ runId, status: "error", error }'}),"."]}),"\n",(0,l.jsxs)(s.li,{children:["Announce delivery runs after the primary run completes and is best-effort; ",(0,l.jsx)(s.code,{children:'status: "ok"'})," does not guarantee the announce was delivered."]}),"\n",(0,l.jsxs)(s.li,{children:["Waits via gateway ",(0,l.jsx)(s.code,{children:"agent.wait"})," (server-side) so reconnects don't drop the wait."]}),"\n",(0,l.jsx)(s.li,{children:"Agent-to-agent message context is injected for the primary run."}),"\n",(0,l.jsxs)(s.li,{children:["After the primary run completes, Moltbot runs a ",(0,l.jsx)(s.strong,{children:"reply-back loop"}),":\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsx)(s.li,{children:"Round 2+ alternates between requester and target agents."}),"\n",(0,l.jsxs)(s.li,{children:["Reply exactly ",(0,l.jsx)(s.code,{children:"REPLY_SKIP"})," to stop the ping\u2011pong."]}),"\n",(0,l.jsxs)(s.li,{children:["Max turns is ",(0,l.jsx)(s.code,{children:"session.agentToAgent.maxPingPongTurns"})," (0\u20135, default 5)."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(s.li,{children:["Once the loop ends, Moltbot runs the ",(0,l.jsx)(s.strong,{children:"agent\u2011to\u2011agent announce step"})," (target agent only):\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Reply exactly ",(0,l.jsx)(s.code,{children:"ANNOUNCE_SKIP"})," to stay silent."]}),"\n",(0,l.jsx)(s.li,{children:"Any other reply is sent to the target channel."}),"\n",(0,l.jsx)(s.li,{children:"Announce step includes the original request + round\u20111 reply + latest ping\u2011pong reply."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"channel-field",children:"Channel Field"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["For groups, ",(0,l.jsx)(s.code,{children:"channel"})," is the channel recorded on the session entry."]}),"\n",(0,l.jsxs)(s.li,{children:["For direct chats, ",(0,l.jsx)(s.code,{children:"channel"})," maps from ",(0,l.jsx)(s.code,{children:"lastChannel"}),"."]}),"\n",(0,l.jsxs)(s.li,{children:["For cron/hook/node, ",(0,l.jsx)(s.code,{children:"channel"})," is ",(0,l.jsx)(s.code,{children:"internal"}),"."]}),"\n",(0,l.jsxs)(s.li,{children:["If missing, ",(0,l.jsx)(s.code,{children:"channel"})," is ",(0,l.jsx)(s.code,{children:"unknown"}),"."]}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"security--send-policy",children:"Security / Send Policy"}),"\n",(0,l.jsx)(s.p,{children:"Policy-based blocking by channel/chat type (not per session id)."}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-json",children:'{\n  "session": {\n    "sendPolicy": {\n      "rules": [\n        {\n          "match": { "channel": "discord", "chatType": "group" },\n          "action": "deny"\n        }\n      ],\n      "default": "allow"\n    }\n  }\n}\n'})}),"\n",(0,l.jsx)(s.p,{children:"Runtime override (per session entry):"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:'sendPolicy: "allow" | "deny"'})," (unset = inherit config)"]}),"\n",(0,l.jsxs)(s.li,{children:["Settable via ",(0,l.jsx)(s.code,{children:"sessions.patch"})," or owner-only ",(0,l.jsx)(s.code,{children:"/send on|off|inherit"})," (standalone message)."]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Enforcement points:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"chat.send"})," / ",(0,l.jsx)(s.code,{children:"agent"})," (gateway)"]}),"\n",(0,l.jsx)(s.li,{children:"auto-reply delivery logic"}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"sessions_spawn",children:"sessions_spawn"}),"\n",(0,l.jsx)(s.p,{children:"Spawn a sub-agent run in an isolated session and announce the result back to the requester chat channel."}),"\n",(0,l.jsx)(s.p,{children:"Parameters:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"task"})," (required)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"label?"})," (optional; used for logs/UI)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"agentId?"})," (optional; spawn under another agent id if allowed)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"model?"})," (optional; overrides the sub-agent model; invalid values error)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"runTimeoutSeconds?"})," (default 0; when set, aborts the sub-agent run after N seconds)"]}),"\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"cleanup?"})," (",(0,l.jsx)(s.code,{children:"delete|keep"}),", default ",(0,l.jsx)(s.code,{children:"keep"}),")"]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Allowlist:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:[(0,l.jsx)(s.code,{children:"agents.list[].subagents.allowAgents"}),": list of agent ids allowed via ",(0,l.jsx)(s.code,{children:"agentId"})," (",(0,l.jsx)(s.code,{children:'["*"]'})," to allow any). Default: only the requester agent."]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Discovery:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Use ",(0,l.jsx)(s.code,{children:"agents_list"})," to discover which agent ids are allowed for ",(0,l.jsx)(s.code,{children:"sessions_spawn"}),"."]}),"\n"]}),"\n",(0,l.jsx)(s.p,{children:"Behavior:"}),"\n",(0,l.jsxs)(s.ul,{children:["\n",(0,l.jsxs)(s.li,{children:["Starts a new ",(0,l.jsx)(s.code,{children:"agent:<agentId>:subagent:<uuid>"})," session with ",(0,l.jsx)(s.code,{children:"deliver: false"}),"."]}),"\n",(0,l.jsxs)(s.li,{children:["Sub-agents default to the full tool set ",(0,l.jsx)(s.strong,{children:"minus session tools"})," (configurable via ",(0,l.jsx)(s.code,{children:"tools.subagents.tools"}),")."]}),"\n",(0,l.jsxs)(s.li,{children:["Sub-agents are not allowed to call ",(0,l.jsx)(s.code,{children:"sessions_spawn"})," (no sub-agent \u2192 sub-agent spawning)."]}),"\n",(0,l.jsxs)(s.li,{children:["Always non-blocking: returns ",(0,l.jsx)(s.code,{children:'{ status: "accepted", runId, childSessionKey }'})," immediately."]}),"\n",(0,l.jsxs)(s.li,{children:["After completion, Moltbot runs a sub-agent ",(0,l.jsx)(s.strong,{children:"announce step"})," and posts the result to the requester chat channel."]}),"\n",(0,l.jsxs)(s.li,{children:["Reply exactly ",(0,l.jsx)(s.code,{children:"ANNOUNCE_SKIP"})," during the announce step to stay silent."]}),"\n",(0,l.jsxs)(s.li,{children:["Announce replies are normalized to ",(0,l.jsx)(s.code,{children:"Status"}),"/",(0,l.jsx)(s.code,{children:"Result"}),"/",(0,l.jsx)(s.code,{children:"Notes"}),"; ",(0,l.jsx)(s.code,{children:"Status"})," comes from runtime outcome (not model text)."]}),"\n",(0,l.jsxs)(s.li,{children:["Sub-agent sessions are auto-archived after ",(0,l.jsx)(s.code,{children:"agents.defaults.subagents.archiveAfterMinutes"})," (default: 60)."]}),"\n",(0,l.jsx)(s.li,{children:"Announce replies include a stats line (runtime, tokens, sessionKey/sessionId, transcript path, and optional cost)."}),"\n"]}),"\n",(0,l.jsx)(s.h2,{id:"sandbox-session-visibility",children:"Sandbox Session Visibility"}),"\n",(0,l.jsxs)(s.p,{children:["Sandboxed sessions can use session tools, but by default they only see sessions they spawned via ",(0,l.jsx)(s.code,{children:"sessions_spawn"}),"."]}),"\n",(0,l.jsx)(s.p,{children:"Config:"}),"\n",(0,l.jsx)(s.pre,{children:(0,l.jsx)(s.code,{className:"language-json5",children:'{\n  agents: {\n    defaults: {\n      sandbox: {\n        // default: "spawned"\n        sessionToolsVisibility: "spawned" // or "all"\n      }\n    }\n  }\n}\n'})})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,l.jsx)(s,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},28453(e,s,n){n.d(s,{R:()=>d,x:()=>r});var i=n(96540);const l={},o=i.createContext(l);function d(e){const s=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);